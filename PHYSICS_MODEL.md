# Physics-Based Fan Optimization Model

## Optimization Goal

**Find the minimal fan speeds that achieve desired temperatures** - balancing cooling performance with noise and power consumption.

Given temperature targets for CPU and GPU, the optimizer finds the lowest fan speeds that maintain those targets. This automatically operates fans efficiently - not too slow (would overheat) and not too fast (would waste energy/make noise).

## System Airflow Diagram

```
                         EXHAUST (1× pwm5)
                              ▲
                              │
    ┌─────────────────────────┴───────────────────────────┐
    │                        CASE                          │
    │                                                      │
    │   ┌──────────────────────────────────┐               │
    │   │   CPU RADIATOR (top, pwm2)       │  ← hot air exits
    │   └──────────────────────────────────┘               │
    │                  ▲                                   │
    │                  │ hot air rises                     │
    │   ┌──────────────────────────────────┐               │
    │   │     GPU (air-cooled)             │               │
    │   │     (has its own fans)           │               │
    │   └──────────────────────────────────┘               │
    │                  ▲                                   │
    │                  │                                   │
    │   ┌──────────────────────────────────┐               │
    │   │   BOTTOM INTAKE (3× pwm4)        │  ← fresh air in
    │   └──────────────────────────────────┘               │
    │                                                      │
    └──────────────────────────────────────────────────────┘
                       │
    FRONT INTAKE ─────►│ (3× pwm5)
```

## Key Thermal Interactions

- **pwm4** (bottom intake): Pushes fresh air up toward GPU, indirectly feeds radiator area
- **pwm5 intake** (front): Supplies fresh air to case, improves overall case airflow
- **pwm5 exhaust** (rear): Removes hot air, creates negative pressure helping intake
- **pwm2** (radiator): Pulls air through CPU radiator, effectiveness depends on case air temperature and pump speed
- **pwm7** (radiator pump): Circulates coolant through CPU waterblock and radiator, affects heat transfer to radiator

## Thermal Physics Fundamentals

The fundamental heat balance equation:

```
T_component = T_ambient + (Power × Thermal_Resistance)
```

Where:
- **Power (W)**: Heat generated by CPU/GPU
- **Thermal Resistance (°C/W)**: How difficult it is to move heat away - reduced by fans

Fans reduce thermal resistance. More airflow = lower resistance = lower temperature for same power.

## Power Measurement

Power is the heat that must be dissipated. Higher load = more watts = more cooling needed.

**Sources:**
- **CPU**: Read from RAPL interface (`/sys/class/powercap/intel-rapl/`) or estimate from utilization
- **GPU**: Read from `nvidia-smi power.draw` or estimate from utilization

Power draw is critical because optimal fan speeds depend on workload - the same temperature at different power levels requires different fan speeds.

## Forward Model Specification

### Inputs

| Variable | Description | Unit | Source |
|----------|-------------|------|--------|
| `pwm2` | Radiator fan speed | 0-255 or % | Control variable |
| `pwm4` | Bottom intake fan speed (3 fans) | 0-255 or % | Control variable |
| `pwm5` | Front intake (3 fans) + rear exhaust (1 fan) speed | 0-255 or % | Control variable |
| `pwm7` | Radiator pump speed | 0-255 or % | Control variable |
| `P_cpu` | CPU power draw | Watts | RAPL / sensors |
| `P_gpu` | GPU power draw | Watts | nvidia-smi |
| `T_amb` | Ambient room temperature | °C | Sensor / Home Assistant |

### Outputs

| Variable | Description | Unit |
|----------|-------------|------|
| `T_cpu` | CPU temperature | °C |
| `T_gpu` | GPU temperature | °C |

## Model Equations

```
T_cpu = T_amb + P_cpu × (R_base_cpu_0 - k_pump·pwm7 + 1 / (a·pwm2·(1 + h·pwm7) + b·pwm4 + c·pwm5 + d))

T_gpu = T_amb + P_gpu × (R_base_gpu + 1 / (e·pwm4 + f·pwm5 + g))
```

### CPU Cooling Model Details

The pump (pwm7) affects CPU cooling through two mechanisms:

1. **Base Resistance Reduction**: Higher pump speed improves coolant circulation, reducing inherent thermal resistance
   ```
   R_base_cpu(pwm7) = R_base_cpu_0 - k_pump·pwm7
   ```

2. **Radiator Fan Coupling**: Higher pump speed delivers more hot coolant to the radiator, making the radiator fan (pwm2) more effective
   ```
   effective_radiator_conductance = a·pwm2·(1 + h·pwm7)
   ```

### Parameters to Fit

| Parameter | Physical Meaning |
|-----------|------------------|
| `R_base_cpu_0` | Fixed thermal resistance without pump effect (waterblock, tubing interface) |
| `k_pump` | Pump speed contribution to reducing base resistance (coolant circulation effectiveness) |
| `R_base_gpu` | Fixed thermal resistance (GPU die to heatsink interface) |
| `a` | pwm2 base contribution to CPU cooling (radiator fan effectiveness) |
| `h` | Pump modulation of radiator fan effectiveness (coolant delivery to radiator) |
| `b` | pwm4 contribution to CPU cooling (bottom intake → fresher air reaches radiator) |
| `c` | pwm5 contribution to CPU cooling (case airflow circulation) |
| `d` | Baseline CPU convection (passive cooling) |
| `e` | pwm4 contribution to GPU cooling (direct airflow from below GPU) |
| `f` | pwm5 contribution to GPU cooling (general case airflow) |
| `g` | Baseline GPU convection (passive cooling) |

**Total: 11 parameters**

## Understanding the Physical Limits

The physics model reveals the absolute best temperatures achievable (fans at infinite speed):

```
T_cpu_min = T_amb + P_cpu × (R_base_cpu_0 - k_pump·pwm7)
T_gpu_min = T_amb + P_gpu × R_base_gpu
```

As fans spin faster, the conductance term `1/(a·pwm + b·pwm + ...)` becomes negligible compared to `R_base`. These are the theoretical minimum temperatures - you can't cool below this without changing hardware (better radiator, waterblock, thermal paste, etc.). For CPU, the pump speed also affects the minimum achievable temperature by improving coolant circulation.

Beyond a certain fan speed, further increases provide diminishing returns. The optimal strategy is to find the **minimum fan speeds that achieve your temperature targets** - this naturally avoids wasted effort.

## Solution Approach

### Problem Formulation

**Given:** Current conditions (P_cpu, P_gpu, T_amb) and temperature targets (T_target_cpu, T_target_gpu)

**Find:** Minimal fan and pump speeds (pwm2, pwm4, pwm5, pwm7) that achieve the targets

### Optimization Formulation

This is a standard constrained nonlinear optimization problem:

```
minimize: w2·pwm2 + w4·pwm4 + w5·pwm5 + w7·pwm7

subject to:
  - T_cpu(pwm2, pwm4, pwm5, pwm7, P_cpu, T_amb) ≤ T_target_cpu
  - T_gpu(pwm4, pwm5, P_gpu, T_amb) ≤ T_target_gpu
  - pwm_i ∈ [min_speed_i, max_speed_i]
```

**Inputs (measured/provided at solve time):**
- `P_cpu`, `P_gpu` - Current power draw (must be measured from RAPL / nvidia-smi)
- `T_amb` - Ambient temperature
- `T_target_cpu`, `T_target_gpu` - Desired temperature targets (usually current temps, or user-set limits)

**Variables to solve for:**
- `pwm2`, `pwm4`, `pwm5`, `pwm7` - Optimal fan and pump speeds

**Parameters (fitted once during calibration):**
- `R_base_cpu_0`, `k_pump`, `R_base_gpu`, `a`, `h`, `b`, `c`, `d`, `e`, `f`, `g` - Thermal model parameters (11 total)

**Where:**
- Weights `w2, w4, w5, w7` can be:
  - All equal (minimize total device speed)
  - Proportional to noise levels (minimize total noise)
  - Proportional to number of fans (pwm4 and pwm5 have 3 fans each, pwm2 and pwm7 have 1 each)

**Solution method:** Use scipy.optimize.minimize with SLSQP or trust-constr solver. The temperature functions are smooth, continuous, and differentiable - ideal for gradient-based optimization.

### Why This Works

By minimizing fan speeds while meeting temperature constraints, we automatically:
- Avoid wasted effort (if fans could be lower, we'd find it)
- Operate efficiently (minimal noise/power for desired cooling)
- Find the optimal balance across multiple fans

The physics model naturally captures diminishing returns through the `1/conductance` term - the solver will find the sweet spot.

### Multi-Fan Coupling

The conductance model includes both linear fan contributions and pump-radiator coupling:
```
conductance_cpu = a·pwm2·(1 + h·pwm7) + b·pwm4 + c·pwm5 + d
```

The pump-radiator coupling term `a·pwm2·(1 + h·pwm7)` captures the interaction between pump speed and radiator fan effectiveness. Other fan contributions (pwm4, pwm5) are assumed independent.

This is still a simplification - in reality:
- Case fans may interact at high speeds
- Airflow patterns may change with fan combinations

**If needed later:** Enhance with additional interaction terms like `j·pwm2·pwm4` or use nonlinear functions. Start with the current model - pump-radiator coupling is the primary interaction.

### Handling Fans That Can Turn Off

Some fans (or other devices) have a minimum operational speed below which they stall. For fans that support OFF (zero speed), the feasible region becomes discontinuous:

```
pwm_i ∈ {0} ∪ [min_speed_i, max_speed_i]
```

**Recommended approach: Hysteresis in Control Logic**

Rather than solving a complex mixed-integer optimization, use a simpler two-threshold strategy:

```
if current_pwm_i == 0:
    turn_on_threshold = min_speed_i + hysteresis_band   # e.g., min_speed + 5%
else:
    turn_off_threshold = min_speed_i - margin            # e.g., min_speed - 5%

Optimizer output → Apply hysteresis logic:
  if optimizer says pwm_i < turn_off_threshold → set to 0
  if optimizer says pwm_i > turn_on_threshold → use optimizer value
  else → maintain current state
```

This avoids oscillation between OFF and minimum speed, and keeps the optimization problem convex and fast. The optimizer solves assuming continuous speeds; the hysteresis layer enforces the discontinuous constraint at runtime.

### Power-Dependent Operation

The model already accounts for power variation - fan requirements automatically scale with workload:
- **Low power** (50W CPU): Model predicts low fan speeds achieve targets
- **High power** (150W CPU): Model predicts higher fan speeds needed

This means fan curves can be generated as functions of both temperature AND power:
```
(pwm2, pwm4, pwm5, pwm7) = solve_optimization(T_target_cpu, T_target_gpu, P_cpu, P_gpu, T_amb)
```

Runtime control simply queries the optimizer with current conditions.

## Data Collection

### Collection Schema

Each row represents one steady-state measurement (after thermal equilibrium):

| Column | Description | Unit |
|--------|-------------|------|
| `timestamp` | Unix timestamp | seconds |
| `pwm2` | Radiator fan speed | 0-255 |
| `pwm4` | Bottom intake speed | 0-255 |
| `pwm5` | Front/rear case fan speed | 0-255 |
| `pwm7` | Radiator pump speed | 0-255 |
| `P_cpu` | CPU power draw | Watts |
| `P_gpu` | GPU power draw | Watts |
| `T_amb` | Ambient temperature | °C |
| `T_cpu` | CPU temperature | °C |
| `T_gpu` | GPU temperature | °C |

### Collection Strategy

Vary fan speeds, pump speed, and loads to capture the full range of operating conditions:

- **Fan speeds**: Test at multiple levels (e.g., 30%, 50%, 70%, 100%) for each fan
- **Pump speed (pwm7)**: Test at multiple levels (e.g., 25%, 50%, 75%, 100%) to capture pump-radiator coupling
- **Load levels**: Vary power draw (idle, CPU-only, GPU-only, mixed workloads)
- **Wide coverage**: Include low and high fan speed combinations to capture the full cooling curve
- **Pump-radiator coupling**: Important to test various combinations of pwm2 (radiator fan) and pwm7 (pump) speeds to fit the coupling parameter `h`
- **Measurements**: ~40-60 steady-state points (wait 30-60s for thermal equilibrium)

**Key principle:** Need measurements across the full range to accurately fit the 11 thermal parameters. The model will then interpolate and extrapolate to any condition. Pay special attention to pump speed variation since it affects both base resistance and radiator fan effectiveness.

## Advantages of This Approach

1. **Physics-Based**: Model reflects actual thermal dynamics, not black-box curve fitting
2. **Minimal Data Required**: ~40-60 data points instead of 1000+ exhaustive combinations
3. **Generalizable**: Works for any intermediate condition via interpolation
4. **Interpretable**: Parameters have physical meaning (resistances, conductances, pump-radiator coupling)
5. **Power-Adaptive**: Accounts for how workload changes optimal fan speeds
6. **Multi-Device Coupling**: Captures how fans and pump interact to cool components
7. **Efficient Optimization**: Can solve for minimal fan/pump speeds via standard constrained optimization
8. **Predictable**: Can simulate "what-if" scenarios without physical testing
9. **Automatic Efficiency**: Minimizing fan/pump speeds inherently avoids wasted effort and finds optimal operating points

## Model Workflow

1. **Data Collection**: Measure temperatures across range of fan speeds, pump speeds, and workloads
   - Plots are automatically generated after each data point (configurable in `config.yaml`)
    - Visualizations saved to `./data/<run_name>/plots/` directory (e.g., `./data/thermal_collection_20240118_120000/plots/`)
   - 9 plot types: correlation matrix, temp vs fans, temp vs power, pump-radiator interaction, thermal resistance, pairwise interactions, cooling effectiveness, ambient normalization, 3D surfaces

2. **Parameter Fitting**: Fit the 11 thermal parameters using least-squares regression (scipy.optimize.curve_fit or similar)

3. **Validation**: Verify model predictions match actual measurements (compute RMSE, plot predicted vs actual)

4. **Optimization Setup**: Implement constrained optimizer to find minimal fan and pump speeds for given temperature targets

5. **Runtime Control**: Query optimizer with current conditions (P_cpu, P_gpu, T_amb) and temperature targets to get optimal fan and pump speeds

6. **Monitoring**: Track model accuracy over time, recalibrate if needed (e.g., dust buildup changes thermal resistance)
