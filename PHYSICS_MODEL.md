# Physics-Based Fan Optimization Model

## Optimization Goal

**Find the minimal fan speeds that achieve desired temperatures** - balancing cooling performance with noise and power consumption.

Given temperature targets for CPU and GPU, the optimizer finds the lowest fan speeds that maintain those targets. This automatically operates fans efficiently - not too slow (would overheat) and not too fast (would waste energy/make noise).

## System Airflow Diagram

```
                         EXHAUST (1× pwm5)
                              ▲
                              │
    ┌─────────────────────────┴───────────────────────────┐
    │                        CASE                          │
    │                                                      │
    │   ┌──────────────────────────────────┐               │
    │   │   CPU RADIATOR (top, pwm2)       │  ← hot air exits
    │   └──────────────────────────────────┘               │
    │                  ▲                                   │
    │                  │ hot air rises                     │
    │   ┌──────────────────────────────────┐               │
    │   │     GPU (air-cooled)             │               │
    │   │     (has its own fans)           │               │
    │   └──────────────────────────────────┘               │
    │                  ▲                                   │
    │                  │                                   │
    │   ┌──────────────────────────────────┐               │
    │   │   BOTTOM INTAKE (3× pwm4)        │  ← fresh air in
    │   └──────────────────────────────────┘               │
    │                                                      │
    └──────────────────────────────────────────────────────┘
                       │
    FRONT INTAKE ─────►│ (3× pwm5)
```

## Key Thermal Interactions

- **pwm4** (bottom intake): Pushes fresh air up toward GPU, indirectly feeds radiator area
- **pwm5 intake** (front): Supplies fresh air to case, improves overall case airflow
- **pwm5 exhaust** (rear): Removes hot air, creates negative pressure helping intake
- **pwm2** (radiator): Pulls air through CPU radiator, effectiveness depends on case air temperature and pump speed
- **pwm7** (radiator pump): Circulates coolant through CPU waterblock and radiator, affects heat transfer to radiator

## Thermal Physics Fundamentals

The fundamental heat balance equation:

```
T_component = T_ambient + (Power × Thermal_Resistance)
```

Where:
- **Power (W)**: Heat generated by CPU/GPU
- **Thermal Resistance (°C/W)**: How difficult it is to move heat away - reduced by fans

Fans reduce thermal resistance. More airflow = lower resistance = lower temperature for same power.

## Power Measurement

Power is the heat that must be dissipated. Higher load = more watts = more cooling needed.

**Sources:**
- **CPU**: Read from RAPL interface (`/sys/class/powercap/intel-rapl/`) or estimate from utilization
- **GPU**: Read from `nvidia-smi power.draw` or estimate from utilization

Power draw is critical because optimal fan speeds depend on workload - the same temperature at different power levels requires different fan speeds.

## Forward Model Specification

### Inputs

| Variable | Description | Unit | Source |
|----------|-------------|------|--------|
| `pwm2` | Radiator fan speed | 0-255 or % | Control variable |
| `pwm4` | Bottom intake fan speed (3 fans) | 0-255 or % | Control variable |
| `pwm5` | Front intake (3 fans) + rear exhaust (1 fan) speed | 0-255 or % | Control variable |
| `pwm7` | Radiator pump speed | 0-255 or % | Control variable |
| `P_cpu` | CPU power draw | Watts | RAPL / sensors |
| `P_gpu` | GPU power draw | Watts | nvidia-smi |
| `T_amb` | Ambient room temperature | °C | Sensor / Home Assistant |

### Outputs

| Variable | Description | Unit |
|----------|-------------|------|
| `T_cpu` | CPU temperature | °C |
| `T_gpu` | GPU temperature | °C |

## Model Equations

```
T_cpu = T_amb + offset_cpu + P_cpu × R_eff_cpu(fans)
T_gpu = T_amb + offset_gpu + P_gpu × R_eff_gpu(fans)
```

Where the effective thermal resistance is:

```
R_eff = R_base / (1 + sum(a_i × sqrt(pwm_i + 1)) / scale)
```

The sqrt function captures **diminishing returns** - fans are most effective at low speeds, with decreasing benefit at high speeds. This is physically realistic for convective cooling.

### Parameters to Fit

**Per-target (CPU and GPU):**

| Parameter | Physical Meaning | Notes |
|-----------|------------------|-------|
| `offset` | Baseline temperature offset | Accounts for idle power, measurement bias, thermal resistance at zero airflow |
| `R_base` | Base thermal resistance without fan cooling | Typical values 0.5-1.0 °C/W for air cooling |
| `a_pwm2` | pwm2 fan cooling effectiveness (if present) | Coefficient for radiator fan (CPU) or primary cooler |
| `a_pwm4` | pwm4 fan cooling effectiveness (if present) | Coefficient for intake fans |
| `a_pwm5` | pwm5 fan cooling effectiveness (if present) | Coefficient for case exhaust fans |
| `scale` | Fan effect scaling parameter | Fixed at 10 for all models |

**Total: 2 + N_fans parameters per target** (e.g., 5 parameters for 3 fans)

## Understanding the Physical Limits

The physics model reveals the absolute best temperatures achievable (fans at infinite speed):

```
T_cpu_min = T_amb + offset_cpu + P_cpu × R_base_cpu
T_gpu_min = T_amb + offset_gpu + P_gpu × R_base_gpu
```

As fans spin faster, the resistance decreases via the `R_base / (1 + fan_effect)` term. At infinite fan speeds, the denominator approaches infinity, making the resistance approach zero. The minimum temperature is limited by:
- Base thermal resistance (`R_base`) - a hardware property
- Ambient temperature (`T_amb`)
- Power draw (`P`)
- Offset term (accounts for unmodeled losses)

These are the theoretical minimum temperatures. You can't cool below this without changing hardware (better radiator, waterblock, thermal paste, etc.).

The `sqrt(pwm + 1)` term naturally captures **diminishing returns** - the marginal cooling benefit decreases at high fan speeds. The optimal strategy is to find the **minimum fan speeds that achieve your temperature targets** - this naturally avoids wasted effort.

## Solution Approach

### Problem Formulation

**Given:** Current conditions (P_cpu, P_gpu, T_amb) and temperature targets (T_target_cpu, T_target_gpu)

**Find:** Minimal fan speeds (pwm2, pwm4, pwm5) that achieve the targets

### Optimization Formulation

This is a standard constrained nonlinear optimization problem:

```
minimize: w2·pwm2 + w4·pwm4 + w5·pwm5

subject to:
  - T_cpu(pwm2, pwm4, pwm5, P_cpu, T_amb) ≤ T_target_cpu
  - T_gpu(pwm4, pwm5, P_gpu, T_amb) ≤ T_target_gpu
  - pwm_i ∈ [min_speed_i, max_speed_i]
```

**Inputs (measured/provided at solve time):**
- `P_cpu`, `P_gpu` - Current power draw (must be measured from RAPL / nvidia-smi)
- `T_amb` - Ambient temperature
- `T_target_cpu`, `T_target_gpu` - Desired temperature targets (usually current temps, or user-set limits)

**Variables to solve for:**
- `pwm2`, `pwm4`, `pwm5` - Optimal fan speeds

**Parameters (fitted once during calibration):**
- `offset_cpu`, `offset_gpu` - Baseline temperature offsets (per-target)
- `R_base_cpu`, `R_base_gpu` - Base thermal resistances (per-target)
- `a_pwm2_cpu`, `a_pwm4_cpu`, `a_pwm5_cpu` - Fan effectiveness coefficients for CPU
- `a_pwm4_gpu`, `a_pwm5_gpu` - Fan effectiveness coefficients for GPU
- **Total: 2 + (N_fans per target) parameters, typically 10-11 total**

**Where:**
- Weights `w2, w4, w5` can be:
  - All equal (minimize total device speed)
  - Proportional to noise levels (minimize total noise)
  - Proportional to number of fans (pwm4 and pwm5 have 3 fans each, pwm2 has 1)

**Solution method:** Use scipy.optimize.minimize with SLSQP or trust-constr solver. The temperature functions are smooth, continuous, and differentiable - ideal for gradient-based optimization.

### Why This Works

By minimizing fan speeds while meeting temperature constraints, we automatically:
- Avoid wasted effort (if fans could be lower, we'd find it)
- Operate efficiently (minimal noise/power for desired cooling)
- Find the optimal balance across multiple fans

The physics model naturally captures diminishing returns through the `1/conductance` term - the solver will find the sweet spot.

### Fan Effects Model

The fan effect is computed as:
```
fan_effect = sum(a_i × sqrt(pwm_i + 1) for all fans i)
```

Each fan contributes independently to the total cooling effectiveness. The sqrt term captures:
- **Diminishing returns**: Fans are most effective at low speeds
- **Continuous smooth function**: Gradient-based optimization works well
- **Realistic physics**: Convective heat transfer coefficient increases with velocity^0.5

This assumes fans contribute independently to the cooling effect. In reality:
- Case fans may interact at very high speeds
- Airflow patterns may change with fan combinations
- Pump circulation (if water-cooled) may couple with radiator fan effectiveness

**If needed later:** Enhance with additional interaction terms or higher-order models. Start with the current independent model - it's simple, interpretable, and typically sufficient for optimization.

### Handling Fans That Can Turn Off

Some fans (or other devices) have a minimum operational speed below which they stall. For fans that support OFF (zero speed), the feasible region becomes discontinuous:

```
pwm_i ∈ {0} ∪ [min_speed_i, max_speed_i]
```

**Recommended approach: Hysteresis in Control Logic**

Rather than solving a complex mixed-integer optimization, use a simpler two-threshold strategy:

```
if current_pwm_i == 0:
    turn_on_threshold = min_speed_i + hysteresis_band   # e.g., min_speed + 5%
else:
    turn_off_threshold = min_speed_i - margin            # e.g., min_speed - 5%

Optimizer output → Apply hysteresis logic:
  if optimizer says pwm_i < turn_off_threshold → set to 0
  if optimizer says pwm_i > turn_on_threshold → use optimizer value
  else → maintain current state
```

This avoids oscillation between OFF and minimum speed, and keeps the optimization problem convex and fast. The optimizer solves assuming continuous speeds; the hysteresis layer enforces the discontinuous constraint at runtime.

### Power-Dependent Operation

The model already accounts for power variation - fan requirements automatically scale with workload:
- **Low power** (50W CPU): Model predicts low fan speeds achieve targets
- **High power** (150W CPU): Model predicts higher fan speeds needed

This means fan curves can be generated as functions of both temperature AND power:
```
(pwm2, pwm4, pwm5, pwm7) = solve_optimization(T_target_cpu, T_target_gpu, P_cpu, P_gpu, T_amb)
```

Runtime control simply queries the optimizer with current conditions.

## Data Collection

### Collection Schema

Each row represents one steady-state measurement (after thermal equilibrium):

| Column | Description | Unit |
|--------|-------------|------|
| `timestamp` | Unix timestamp | seconds |
| `pwm2` | Radiator fan speed | 0-255 |
| `pwm4` | Bottom intake speed | 0-255 |
| `pwm5` | Front/rear case fan speed | 0-255 |
| `pwm7` | Radiator pump speed | 0-255 |
| `P_cpu` | CPU power draw | Watts |
| `P_gpu` | GPU power draw | Watts |
| `T_amb` | Ambient temperature | °C |
| `T_cpu` | CPU temperature | °C |
| `T_gpu` | GPU temperature | °C |

### Collection Strategy

Vary fan speeds and loads to capture the full range of operating conditions:

- **Fan speeds**: Test at multiple levels (e.g., 30%, 50%, 70%, 100%) for each fan
- **Load levels**: Vary power draw (idle, CPU-only, GPU-only, mixed workloads)
- **Wide coverage**: Include low and high fan speed combinations to capture the full cooling curve
- **Fan combinations**: Test various combinations of pwm2, pwm4, pwm5 to capture independent and synergistic effects
- **Measurements**: ~40-60 steady-state points (wait 30-60s for thermal equilibrium)

**Key principle:** Need measurements across the full range to accurately fit the thermal parameters (2 + N_fans per target). The model will then interpolate and extrapolate to any condition. Focus on covering the extremes (fans at min/max) and representative midrange conditions.

## Advantages of This Approach

1. **Physics-Based**: Model reflects actual thermal dynamics, not black-box curve fitting
2. **Minimal Data Required**: ~40-60 data points instead of 1000+ exhaustive combinations
3. **Generalizable**: Works for any intermediate condition via interpolation
4. **Interpretable**: Parameters have physical meaning (thermal resistances, fan effectiveness coefficients)
5. **Power-Adaptive**: Accounts for how workload changes optimal fan speeds
6. **Smooth & Differentiable**: sqrt function ensures smooth response, perfect for gradient-based optimization
7. **Efficient Optimization**: Can solve for minimal fan speeds via standard constrained optimization
8. **Predictable**: Can simulate "what-if" scenarios without physical testing
9. **Automatic Efficiency**: Minimizing fan speeds inherently avoids wasted effort and finds optimal operating points
10. **Diminishing Returns Built-In**: sqrt term naturally models realistic convective cooling behavior

## Model Workflow

1. **Data Collection**: Measure temperatures across range of fan speeds and workloads
   - Plots are automatically generated after each data point (configurable in `config.yaml`)
   - Visualizations saved to `./data/<run_name>/plots/` directory (e.g., `./data/thermal_collection_20240118_120000/plots/`)
   - 9 plot types: correlation matrix, temp vs fans, temp vs power, thermal resistance, pairwise interactions, cooling effectiveness, ambient normalization, 3D surfaces

2. **Parameter Fitting**: Fit thermal parameters (offset, R_base, fan coefficients) using least-squares regression (scipy.optimize.minimize or similar)

3. **Validation**: Verify model predictions match actual measurements (compute RMSE, plot predicted vs actual)

4. **Optimization Setup**: Implement constrained optimizer to find minimal fan speeds for given temperature targets

5. **Runtime Control**: Query optimizer with current conditions (P_cpu, P_gpu, T_amb) and temperature targets to get optimal fan speeds

6. **Monitoring**: Track model accuracy over time, recalibrate if needed (e.g., dust buildup changes thermal resistance)
